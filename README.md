twisted-pyro
============

Provides a Deferred-based interface for Pyro4's client calls and a Factory/Protocol that provides server-side Pyro4 support.

This is a preliminary (alpha) effort, but feel free to use or contribute!

Introduction
============

I needed to migrate a [Pyro4](http://pythonhosted.org/Pyro4/) application to [Twisted](twistedmatrix.com).  To simplify testing, I wanted to move it in pieces.  Unfortunately, Pyro4 is a synchronous application and Twisted is an asynchronous application so they didn't play well together.  This package includes a variety of client- and server-side classes to enable the two to coexist.

Client: PyroDeferredService
===========================

I was pleased to learn that Pyro4 had an async interface until I dug into the details.  The biggest problem was that Pyro's `FutureResult` (equivalent to `Deferred`) provided no [errback](http://twistedmatrix.com/documents/13.0.0/core/howto/defer.html#auto4) strategy.  Instead, it consumes all errors, trashing the callback chain.  I also had concerns about thread safety since all of FutureResult's `.then()` calls (equivalent to `addCallback()`) run in a separate thread along with the original async call (see the second sentence of the [Note](https://pythonhosted.org/Pyro4/clientcode.html#asynchronous-future-remote-calls-call-chains)).

This package attempts to address both issues by making deep modifications (private and mangled) to Pyro4.Proxy and its associated async classes:
 - Calls still use the standard (to Pyro4) `proxy.method()` interface but now return a `Deferred`.
 - This `Deferred` starts with a single callback (with one ignored parameter) that gets and returns the FutureResult's result (or raises the FutureResult's error).
 - To maximize thread safety, the Deferred's callback is triggered indirectly.  Specifically, Pyro's `FutureResult` object includes only one callback (run in Pyro's async thread) which calls `reactor.callLater(0, d.callback, None)`.
 - I'm reasonably confident that this will always push the Deferred's actual callback execution into the Reactor's thread, providing thread safety.
 - In principle, the Deferred's first callback (to get the FutureResult's value) blocks, but the callback should only occur after a value (or an exception) is available locally.
 
To set up a connection to base, simply run:

    import Pyro4
    import pyro.proxy
    
    # The Pyro4.Proxy is "out of the box" so you can use any standard URI
    uri = "my_pyro_uri"
    proxy = Pyro4.Proxy(uri)
    deferred_generating_proxy = pyro.proxy.PyroDeferredService(proxy)
    
    # As mentioned above, calls use the "transparent" proxy.method() syntax:
    deferred = deferred_generating_proxy.remote_method()

Server: Pyro4Protocol & Pyro4ProtocolFactory
============================================

The first migrated component only needed to use Pyro4 as a client.  To migrate additional components, I needed an implementation of Pyro4's server-side logic inside Twisted.  As is true of most synchronous code, minor modifications were not going to do the trick.  Instead, I rearranged existing Pyro4 logic (found mostly in Daemon.handleRequest and Message.recv) into Twisted's Protocol and Factory framework.  Since this code continues to use significant portions of the Pyro4 core, it's possible (but by no means certain) that it will support past and future Pyro4 versions.

twisted-pyro shares most of its syntax with Pyro4:

	factory = pyro.protocol.Pyro4ClientFactory()
	tcp_port = pyro.protocol.reactor.listenTCP(5555, factory)
	# Because the reactor is responsible for the actual TCP connection, we 
	# have to proactively route the data back into the factory to ensure 
	# that URIs generated by the factory include correct location data.
	host = getInterfaceAddress("8.8.8.8")
	port = tcp_port.getHost().port
	factory.setAddress(host, port)

	foo = Foo()
	bar = Bar()
	fooUri = factory.register(foo)
	barUri = factory.register(bar)
	# Like Pyro4, the URIs need to be registered with a nameserver or 
	# otherwise transferred to clients.

NOTE:  Unlike the standard Pyro4 syntax, Twisted permits a single ProtocolFactory to be attached to multiple Transports (e.g. ports attached to interfaces).  It also allows you to bind to all interfaces (host: 0.0.0.0).  This makes it difficult for the Factory to determine which host and port should be used in the URI.
	
Due to differences between synchronous and asynchronous approaches, twisted-pyro depends heavily on states to determine how data should be routed.  Because state data need not persist across connections (unlike state information in many applications), it is attached to the Protocol.  These states are:

 - server:  indicates that a handshake will be required upon connection
 - header (default):  waiting on enough data to parse a message header and respond accordingly
 - annotations:  header parsed, waiting on amount of annotation data requested in header
 - data:  header parsed, waiting on amount of data requested in header
 - response:  we owe a response

Other:  PyroPatientProxy
========================

The proxy file also includes `PyroPatientProxy`, an implementation of `Pyro4.Proxy` that doesn't raise NamingError.  This means that the proxy will retry its search for the nameserver not just the remote daemon.  By default, this occurs no more than once every 2 seconds for 43200 retries (24h plus any delay in the retry schedule).  Since calls to this object can block "indefinitely", it should ONLY be used in conjunction with the `PyroDeferredService` or Pyro4's `_AsyncProxyAdapter` accessed by calling `Pyro4.async(proxy)`.  **PLEASE NOTE THAT THIS PROXY WILL START WITHOUT A NAMING SERVER.  IF YOU USE THE CLASS, YOU ARE RESPONSIBLE FOR ENSURING EVENTUAL ACCESS TO A NAMING SERVER.  OTHERWISE, IT WILL SIT IDLE FOR AT LEAST 24H BEFORE RASING AN EXCEPTION.**

